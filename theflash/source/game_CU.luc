module game_CU (
    input clk,  // clock
    input rst,  // reset
    input fast_counter,                    // counter to trigger the enemies to blink on and off
    input slow_counter,                    // timer for future implementations of a player's score
    input forward_pressed,                 // button signal by player to move forward
    input backward_pressed,                // button signal by player to move backward
    input reset_pressed,                   // button signal by player to reset
    input rb_data[16],                     // data retrieved from the regfile for branching
    
    // control signals for the Custom Beta
    output control_sig_alufn[6],           
    output control_sig_asel[2],            
    output control_sig_bsel[2],
    output control_sig_write_enable,
    output control_sig_ra[5],
    output control_sig_rb[5],
    output control_sig_rc[5],
    output control_sig_wdsel[2],
    
    // 'state number' and 'result' values are for debugging purposes
    output state_number[7],
    output result[16]     
  ) {
  .clk(clk){
  
    fsm game_fsm={
      IDLE, 
      CHECK_PP, 
      PP_PLUS,
      PP_MINUS, 
      BRANCH_PP,
      CHECKPP_EQ_E1, 
      CHECKPP_EQ_E2, 
      CHECKPP_EQ_E3, 
      CHECKPP_EQ_E4, 
      CHECKPP_EQ_E5, 
      CHECKPP_EQ_E6, 
      CHECKPP_EQ_E7,
      CHECKPP_EQ_E8,
      CHECKPP_EQ_E9,
      CHECKPP_EQ_E10,
      CHECKPP_EQ_E11, 
      CHECKPP_EQ_E12,
      CHECKPP_EQ_E13,
      CHECKPP_EQ_E14,
      CHECKPP_EQ_E15,
      CHECKPP_EQ_E16,
      BRANCH_PP_EQ_E1,
      BRANCH_PP_EQ_E2,
      BRANCH_PP_EQ_E3,
      BRANCH_PP_EQ_E4,
      BRANCH_PP_EQ_E5,
      BRANCH_PP_EQ_E6,
      BRANCH_PP_EQ_E7,
      BRANCH_PP_EQ_E8,
      BRANCH_PP_EQ_E9,
      BRANCH_PP_EQ_E10,
      BRANCH_PP_EQ_E11,
      BRANCH_PP_EQ_E12,
      BRANCH_PP_EQ_E13,
      BRANCH_PP_EQ_E14,
      BRANCH_PP_EQ_E15,
      BRANCH_PP_EQ_E16,
      CHECK_END_REACHED,
      BRANCH_END_REACHED,
      CHECK_NEXTLVL_EXISTS,
      BRANCH_NEXT_LVL_EXISTS,
      WIN,
      CURRENT_LVL_PLUS,
      NEXT_LVL_PP,
      RESET_PP,
      RESET_STOP_GAME,
      RESET_FAST_COUNTER,
      RESET_SLOW_COUNTER,
      RESET_LIVES,
      RESET_LVL,
      CHECK_STOP_GAME,
      BRANCH_STOP_GAME,
      SLOW_COUNTER_PLUS,
      FAST_COUNTER_PLUS,
      CHECK_LVL_EQ_3,
      BRANCH_LVL_EQ_3,
      CHECK_LVL_EQ_2,
      BRANCH_LVL_EQ_2,
      CHECK_FAST_COUNTER_MOD_3,
      BRANCH_FAST_COUNTER_MOD_3,
      CHECK_FAST_COUNTER_MOD_2,
      BRANCH_FAST_COUNTER_MOD_2,
      BLINK_E1,
      BLINK_E2,
      BLINK_E3,
      BLINK_E4,
      BLINK_E5,
      BLINK_E6,
      BLINK_E7,
      BLINK_E8,
      BLINK_E9,
      BLINK_E10,
      BLINK_E11,
      BLINK_E12,
      BLINK_E13,
      BLINK_E14,
      BLINK_E15,
      BLINK_E16,
      CHECK_LIVES_MORE_THAN_1,
      BRANCH_LIVES_MORE_THAN_1,
      LIVES_MINUS,
      LOSE,
      LOSE_LIVES,
      RESPAWN_PP,
      TEMP_STATE,
      RESET_E1,
      RESET_E2,
      RESET_E3,
      RESET_E4,
      RESET_E5,
      RESET_E6,
      RESET_E7,
      RESET_E8,
      RESET_E9,
      RESET_E10,
      RESET_E11};
  }
  
  
  sig done;
  
  always {
    
    // standard setting unless otherwise overwritten by each case 
    control_sig_alufn        = 000000;
    control_sig_asel         = 00;
    control_sig_bsel         = 00;
    control_sig_write_enable = 0;
    control_sig_ra           = 00000;
    control_sig_rb           = 00000;
    control_sig_rc           = 00000;
    control_sig_wdsel        = 00;
    state_number = b0000000;
    done = 0;
    result = 0;
    

    
    if (rst){
        // game_fsm.d = game_fsm.RESET_PP;
    }
    else{
      
    case(game_fsm.q){
    
     game_fsm.IDLE: // idle state waiting for different events to trigger a path of operations to be carried out
        
        state_number             = b0000001;
       
        control_sig_write_enable = b0;

          if (fast_counter){    // fast counter to toggle enemies state / blinking                     
            game_fsm.d = game_fsm.FAST_COUNTER_PLUS;
          }
          else if(slow_counter){
            game_fsm.d =  game_fsm.CHECK_STOP_GAME;
          }
          else if(forward_pressed){
            game_fsm.d =  game_fsm.PP_PLUS;
          }
          else if(backward_pressed){
            game_fsm.d =  game_fsm.CHECK_PP;
          }
          else if(reset_pressed){
            game_fsm.d =  game_fsm.RESET_PP;
          }
          else {game_fsm.d =  game_fsm.IDLE;}

     game_fsm.FAST_COUNTER_PLUS:
        state_number             = b0000000;   // State number 0
        control_sig_alufn        = b000000;    // ALU operation ADD 
        control_sig_asel         = b10;        // Select constant 1 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b10011;     // Register to store fast counter's value 
        control_sig_rc           = b10011;     // Register to store fast counter's value 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.CHECK_LVL_EQ_3;

     game_fsm.CHECK_LVL_EQ_3:
        state_number             = b0000001;   // State number 1
        control_sig_alufn        = b110011;    // ALU operation for CMPEQ 
        control_sig_asel         = b11;        // Select constant 3 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b10010;     // Register to store Player's current level 
        control_sig_rc           = b10111;     // Temporary register to store output from ALU 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BRANCH_LVL_EQ_3;

     game_fsm.BRANCH_LVL_EQ_3:
        state_number             = b0000010;   // State number 2
        control_sig_rb           = b10111;     // Temporary register to store output from ALU 
        control_sig_write_enable = b0;         // Disable writing to regfile 

        if (rb_data[0] == 1){
          game_fsm.d = game_fsm.BLINK_E1;
        }
        else{ game_fsm.d = game_fsm.CHECK_LVL_EQ_2;}

     game_fsm.CHECK_LVL_EQ_2:
        state_number             = b0000011;   // State number 3
        control_sig_alufn        = b110011;    // ALU operation for CMPEQ 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b11;        // Select constant 2 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b10010;     // Register to store Player's current level 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b10111;     // Temporary register to store output from ALU 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BRANCH_LVL_EQ_2;

     game_fsm.BRANCH_LVL_EQ_2:
        state_number             = b0000100;   // State number 4
        control_sig_rb           = b10111;     // Temporary register to store output from ALU 
        control_sig_write_enable = b0;         // Disable writing to regfile 

        if (rb_data[0] == 1){
          game_fsm.d = game_fsm.CHECK_FAST_COUNTER_MOD_2;
        }
        else{ game_fsm.d = game_fsm.CHECK_FAST_COUNTER_MOD_3;}

     game_fsm.CHECK_FAST_COUNTER_MOD_2:
        state_number             = b0000101;   // State number 5
        control_sig_alufn        = b000111;    // ALU operation MODULO 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b11;        // Select constant 2 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b10011;     // Register to store fast counter's value 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b10111;     // Temporary register to store output from ALU 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BRANCH_FAST_COUNTER_MOD_2;

     game_fsm.BRANCH_FAST_COUNTER_MOD_2:
        state_number             = b0000110;   // State number 6
        control_sig_rb           = b10111;     // Temporary register to store output from ALU 
        control_sig_write_enable = b0;         // Disable writing to regfile 

        if (rb_data[0] == 1){
          game_fsm.d = game_fsm.BLINK_E7;
        }
        else{ game_fsm.d = game_fsm.IDLE;}

     game_fsm.CHECK_FAST_COUNTER_MOD_3:
        state_number             = b0000111;   // State number 7
        control_sig_alufn        = b000111;    // ALU operation MODULO 
        control_sig_asel         = b11;        // Select constant 3 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b10011;     // Register to store fast counter's value 
        control_sig_rc           = b10111;     // Temporary register to store output from ALU 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BRANCH_FAST_COUNTER_MOD_3;

     game_fsm.BRANCH_FAST_COUNTER_MOD_3:
        state_number             = b0001000;   // State number 8
        control_sig_rb           = b10111;     // Temporary register to store output from ALU 
        control_sig_write_enable = b0;         // Disable writing to regfile 

        if (rb_data[0] == 1){
          game_fsm.d = game_fsm.BLINK_E12;
        }
        else{ game_fsm.d = game_fsm.IDLE;}

     game_fsm.BLINK_E1:
        state_number             = b0001001;   // State number 9
        control_sig_alufn        = b010100;    // Custom ALU operation to toggle MSB for enemies 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00001;     // Register to store Enemy 1's state and position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b00001;     // Register to store Enemy 1's state and position 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BLINK_E2;

     game_fsm.BLINK_E2:
        state_number             = b0001010;   // State number 10
        control_sig_alufn        = b010100;    // Custom ALU operation to toggle MSB for enemies 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00010;     // Register to store Enemy 2's state and position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b00010;     // Register to store Enemy 2's state and position 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BLINK_E3;

     game_fsm.BLINK_E3:
        state_number             = b0001011;   // State number 11
        control_sig_alufn        = b010100;    // Custom ALU operation to toggle MSB for enemies 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00011;     // Register to store Enemy 3's state and position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b00011;     // Register to store Enemy 3's state and position 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BLINK_E4;

     game_fsm.BLINK_E4:
        state_number             = b0001100;   // State number 12
        control_sig_alufn        = b010100;    // Custom ALU operation to toggle MSB for enemies 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00100;     // Register to store Enemy 4's state and position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b00100;     // Register to store Enemy 4's state and position 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BLINK_E5;

     game_fsm.BLINK_E5:
        state_number             = b0001101;   // State number 13
        control_sig_alufn        = b010100;    // Custom ALU operation to toggle MSB for enemies 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00101;     // Register to store Enemy 5's state and position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b00101;     // Register to store Enemy 5's state and position 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BLINK_E6;

     game_fsm.BLINK_E6:
        state_number             = b0001110;   // State number 14
        control_sig_alufn        = b010100;    // Custom ALU operation to toggle MSB for enemies 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00110;     // Register to store Enemy 6's state and position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b00110;     // Register to store Enemy 6's state and position 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BLINK_E7;

     game_fsm.BLINK_E7:
        state_number             = b0001111;   // State number 15
        control_sig_alufn        = b010100;    // Custom ALU operation to toggle MSB for enemies 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00111;     // Register to store Enemy 7's state and position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b00111;     // Register to store Enemy 7's state and position 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BLINK_E8;

     game_fsm.BLINK_E8:
        state_number             = b0010000;   // State number 16
        control_sig_alufn        = b010100;    // Custom ALU operation to toggle MSB for enemies 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b01000;     // Register to store Enemy 8's state and position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b01000;     // Register to store Enemy 8's state and position 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BLINK_E9;

     game_fsm.BLINK_E9:
        state_number             = b0010001;   // State number 17
        control_sig_alufn        = b010100;    // Custom ALU operation to toggle MSB for enemies 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b01001;     // Register to store Enemy 9's state and position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b01001;     // Register to store Enemy 9's state and position 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BLINK_E10;

     game_fsm.BLINK_E10:
        state_number             = b0010010;   // State number 18
        control_sig_alufn        = b010100;    // Custom ALU operation to toggle MSB for enemies 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b01010;     // Register to store Enemy 10's state and position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b01010;     // Register to store Enemy 10's state and position 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BLINK_E11;

     game_fsm.BLINK_E11:
        state_number             = b0010011;   // State number 19
        control_sig_alufn        = b010100;    // Custom ALU operation to toggle MSB for enemies 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b01011;     // Register to store Enemy 11's state and position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b01011;     // Register to store Enemy 11's state and position 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BLINK_E12;

     game_fsm.BLINK_E12:
        state_number             = b0010100;   // State number 20
        control_sig_alufn        = b010100;    // Custom ALU operation to toggle MSB for enemies 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b01100;     // Register to store Enemy 12's state and position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b01100;     // Register to store Enemy 12's state and position 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BLINK_E13;

     game_fsm.BLINK_E13:
        state_number             = b0010101;   // State number 21
        control_sig_alufn        = b010100;    // Custom ALU operation to toggle MSB for enemies 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b01101;     // Register to store Enemy 13's state and position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b01101;     // Register to store Enemy 13's state and position 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BLINK_E14;

     game_fsm.BLINK_E14:
        state_number             = b0010110;   // State number 22
        control_sig_alufn        = b010100;    // Custom ALU operation to toggle MSB for enemies 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b01110;     // Register to store Enemy 14's state and position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b01110;     // Register to store Enemy 14's state and position 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BLINK_E15;

     game_fsm.BLINK_E15:
        state_number             = b0010111;   // State number 23
        control_sig_alufn        = b010100;    // Custom ALU operation to toggle MSB for enemies 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b01111;     // Register to store Enemy 15's state and position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b01111;     // Register to store Enemy 15's state and position 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BLINK_E16;

     game_fsm.BLINK_E16:
        state_number             = b0011000;   // State number 24
        control_sig_alufn        = b010100;    // Custom ALU operation to toggle MSB for enemies 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b10000;     // Register to store Enemy 16's state and position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b10000;     // Register to store Enemy 16's state and position 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.CHECKPP_EQ_E1;

     game_fsm.CHECKPP_EQ_E1:
        state_number             = b0011001;   // State number 25
        control_sig_alufn        = b110011;    // ALU operation for CMPEQ 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b00001;     // Register to store Enemy 1's state and position 
        control_sig_rc           = b10111;     // Temporary register to store output from ALU 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BRANCH_PP_EQ_E1;

     game_fsm.BRANCH_PP_EQ_E1:
        state_number             = b0011010;   // State number 26
        control_sig_rb           = b10111;     // Temporary register to store output from ALU 
        control_sig_write_enable = b0;         // Disable writing to regfile 
        result = rb_data;

        if (rb_data[0] == 1){
          game_fsm.d = game_fsm.CHECK_LIVES_MORE_THAN_1;
        }
        else game_fsm.d = game_fsm.CHECKPP_EQ_E2;
          
     game_fsm.CHECKPP_EQ_E2:
        state_number             = b0011011;   // State number 27
        control_sig_alufn        = b110011;    // ALU operation for CMPEQ 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b00010;     // Register to store Enemy 2's state and position 
        control_sig_rc           = b10111;     // Temporary register to store output from ALU 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BRANCH_PP_EQ_E2;

     game_fsm.BRANCH_PP_EQ_E2:
        state_number             = b0011100;   // State number 28
        control_sig_rb           = b10111;     // Temporary register to store output from ALU 
        control_sig_write_enable = b0;         // Disable writing to regfile 

        if (rb_data[0] == 1){
          game_fsm.d = game_fsm.CHECK_LIVES_MORE_THAN_1;
        }
        else game_fsm.d = game_fsm.CHECKPP_EQ_E3;
     game_fsm.CHECKPP_EQ_E3:
        state_number             = b0011101;   // State number 29
        control_sig_alufn        = b110011;    // ALU operation for CMPEQ 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b00011;     // Register to store Enemy 3's state and position 
        control_sig_rc           = b10111;     // Temporary register to store output from ALU 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BRANCH_PP_EQ_E3;

     game_fsm.BRANCH_PP_EQ_E3:
        state_number             = b0011110;   // State number 30
        control_sig_rb           = b10111;     // Temporary register to store output from ALU 
        control_sig_write_enable = b0;         // Disable writing to regfile 

        if (rb_data[0] == 1){
          game_fsm.d = game_fsm.CHECK_LIVES_MORE_THAN_1;
        }
        else game_fsm.d = game_fsm.CHECKPP_EQ_E4;
     game_fsm.CHECKPP_EQ_E4:
        state_number             = b0011111;   // State number 31
        control_sig_alufn        = b110011;    // ALU operation for CMPEQ 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b00100;     // Register to store Enemy 4's state and position 
        control_sig_rc           = b10111;     // Temporary register to store output from ALU 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BRANCH_PP_EQ_E4;

     game_fsm.BRANCH_PP_EQ_E4:
        state_number             = b0100000;   // State number 32
        control_sig_rb           = b10111;     // Temporary register to store output from ALU 
        control_sig_write_enable = b0;         // Disable writing to regfile 

        if (rb_data[0] == 1){
          game_fsm.d = game_fsm.CHECK_LIVES_MORE_THAN_1;
        }
        else game_fsm.d = game_fsm.CHECKPP_EQ_E5;
     game_fsm.CHECKPP_EQ_E5:
        state_number             = b0100001;   // State number 33
        control_sig_alufn        = b110011;    // ALU operation for CMPEQ 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b00101;     // Register to store Enemy 5's state and position 
        control_sig_rc           = b10111;     // Temporary register to store output from ALU 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BRANCH_PP_EQ_E5;

     game_fsm.BRANCH_PP_EQ_E5:
        state_number             = b0100010;   // State number 34
        control_sig_rb           = b10111;     // Temporary register to store output from ALU 
        control_sig_write_enable = b0;         // Disable writing to regfile 

        if (rb_data[0] == 1){
          game_fsm.d = game_fsm.CHECK_LIVES_MORE_THAN_1;
        }
        else game_fsm.d = game_fsm.CHECKPP_EQ_E6;
     game_fsm.CHECKPP_EQ_E6:
        state_number             = b0100011;   // State number 35
        control_sig_alufn        = b110011;    // ALU operation for CMPEQ 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b00110;     // Register to store Enemy 6's state and position 
        control_sig_rc           = b10111;     // Temporary register to store output from ALU 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BRANCH_PP_EQ_E6;

     game_fsm.BRANCH_PP_EQ_E6:
        state_number             = b0100100;   // State number 36
        control_sig_rb           = b10111;     // Temporary register to store output from ALU 
        control_sig_write_enable = b0;         // Disable writing to regfile 

        if (rb_data[0] == 1){
          game_fsm.d = game_fsm.CHECK_LIVES_MORE_THAN_1;
        }
        else game_fsm.d = game_fsm.CHECKPP_EQ_E7;
     game_fsm.CHECKPP_EQ_E7:
        state_number             = b0100101;   // State number 37
        control_sig_alufn        = b110011;    // ALU operation for CMPEQ 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b00111;     // Register to store Enemy 7's state and position 
        control_sig_rc           = b10111;     // Temporary register to store output from ALU 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BRANCH_PP_EQ_E7;

     game_fsm.BRANCH_PP_EQ_E7:
        state_number             = b0100110;   // State number 38
        control_sig_rb           = b10111;     // Temporary register to store output from ALU 
        control_sig_write_enable = b0;         // Disable writing to regfile 

        if (rb_data[0] == 1){
          game_fsm.d = game_fsm.CHECK_LIVES_MORE_THAN_1;
        }
        else game_fsm.d = game_fsm.CHECKPP_EQ_E8;
     game_fsm.CHECKPP_EQ_E8:
        state_number             = b0100111;   // State number 39
        control_sig_alufn        = b110011;    // ALU operation for CMPEQ 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b01000;     // Register to store Enemy 8's state and position 
        control_sig_rc           = b10111;     // Temporary register to store output from ALU 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BRANCH_PP_EQ_E8;

     game_fsm.BRANCH_PP_EQ_E8:
        state_number             = b0101000;   // State number 40
        control_sig_rb           = b10111;     // Temporary register to store output from ALU 
        control_sig_write_enable = b0;         // Disable writing to regfile 

        if (rb_data[0] == 1){
          game_fsm.d = game_fsm.CHECK_LIVES_MORE_THAN_1;
        }
        else game_fsm.d = game_fsm.CHECKPP_EQ_E9;
     game_fsm.CHECKPP_EQ_E9:
        state_number             = b0101001;   // State number 41
        control_sig_alufn        = b110011;    // ALU operation for CMPEQ 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b01001;     // Register to store Enemy 9's state and position 
        control_sig_rc           = b10111;     // Temporary register to store output from ALU 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BRANCH_PP_EQ_E9;

     game_fsm.BRANCH_PP_EQ_E9:
        state_number             = b0101010;   // State number 42
        control_sig_rb           = b10111;     // Temporary register to store output from ALU 
        control_sig_write_enable = b0;         // Disable writing to regfile 

        if (rb_data[0] == 1){
          game_fsm.d = game_fsm.CHECK_LIVES_MORE_THAN_1;
        }
        else game_fsm.d = game_fsm.CHECKPP_EQ_E10;
     game_fsm.CHECKPP_EQ_E10:
        state_number             = b0101011;   // State number 43
        control_sig_alufn        = b110011;    // ALU operation for CMPEQ 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b01010;     // Register to store Enemy 10's state and position 
        control_sig_rc           = b10111;     // Temporary register to store output from ALU 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BRANCH_PP_EQ_E10;

     game_fsm.BRANCH_PP_EQ_E10:
        state_number             = b0101100;   // State number 44
        control_sig_rb           = b10111;     // Temporary register to store output from ALU 
        control_sig_write_enable = b0;         // Disable writing to regfile 

        if (rb_data[0] == 1){
          game_fsm.d = game_fsm.CHECK_LIVES_MORE_THAN_1;
        }
        else game_fsm.d = game_fsm.CHECKPP_EQ_E11;
     game_fsm.CHECKPP_EQ_E11:
        state_number             = b0101101;   // State number 45
        control_sig_alufn        = b110011;    // ALU operation for CMPEQ 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b01011;     // Register to store Enemy 11's state and position 
        control_sig_rc           = b10111;     // Temporary register to store output from ALU 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BRANCH_PP_EQ_E11;

     game_fsm.BRANCH_PP_EQ_E11:
        state_number             = b0101110;   // State number 46
        control_sig_rb           = b10111;     // Temporary register to store output from ALU 
        control_sig_write_enable = b0;         // Disable writing to regfile 

        if (rb_data[0] == 1){
          game_fsm.d = game_fsm.CHECK_LIVES_MORE_THAN_1;
        }
        else game_fsm.d = game_fsm.CHECKPP_EQ_E12;
     game_fsm.CHECKPP_EQ_E12:
        state_number             = b0101111;   // State number 47
        control_sig_alufn        = b110011;    // ALU operation for CMPEQ 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b01100;     // Register to store Enemy 12's state and position 
        control_sig_rc           = b10111;     // Temporary register to store output from ALU 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BRANCH_PP_EQ_E12;

     game_fsm.BRANCH_PP_EQ_E12:
        state_number             = b0110000;   // State number 48
        control_sig_rb           = b10111;     // Temporary register to store output from ALU 
        control_sig_write_enable = b0;         // Disable writing to regfile 

        if (rb_data[0] == 1){
          game_fsm.d = game_fsm.CHECK_LIVES_MORE_THAN_1;
        }
        else game_fsm.d = game_fsm.CHECKPP_EQ_E13;
     game_fsm.CHECKPP_EQ_E13:
        state_number             = b0110001;   // State number 49
        control_sig_alufn        = b110011;    // ALU operation for CMPEQ 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b01101;     // Register to store Enemy 13's state and position 
        control_sig_rc           = b10111;     // Temporary register to store output from ALU 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BRANCH_PP_EQ_E13;

     game_fsm.BRANCH_PP_EQ_E13:
        state_number             = b0110010;   // State number 50
        control_sig_rb           = b10111;     // Temporary register to store output from ALU 
        control_sig_write_enable = b0;         // Disable writing to regfile 

        if (rb_data[0] == 1){
          game_fsm.d = game_fsm.CHECK_LIVES_MORE_THAN_1;
        }
        else game_fsm.d = game_fsm.CHECKPP_EQ_E14;
     game_fsm.CHECKPP_EQ_E14:
        state_number             = b0110011;   // State number 51
        control_sig_alufn        = b110011;    // ALU operation for CMPEQ 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b01110;     // Register to store Enemy 14's state and position 
        control_sig_rc           = b10111;     // Temporary register to store output from ALU 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BRANCH_PP_EQ_E14;

     game_fsm.BRANCH_PP_EQ_E14:
        state_number             = b0110100;   // State number 52
        control_sig_rb           = b10111;     // Temporary register to store output from ALU 
        control_sig_write_enable = b0;         // Disable writing to regfile 

        if (rb_data[0] == 1){
          game_fsm.d = game_fsm.CHECK_LIVES_MORE_THAN_1;
        }
        else game_fsm.d = game_fsm.CHECKPP_EQ_E15;
     game_fsm.CHECKPP_EQ_E15:
        state_number             = b0110101;   // State number 53
        control_sig_alufn        = b110011;    // ALU operation for CMPEQ 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b01111;     // Register to store Enemy 15's state and position 
        control_sig_rc           = b10111;     // Temporary register to store output from ALU 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BRANCH_PP_EQ_E15;

     game_fsm.BRANCH_PP_EQ_E15:
        state_number             = b0110110;   // State number 54
        control_sig_rb           = b10111;     // Temporary register to store output from ALU 
        control_sig_write_enable = b0;         // Disable writing to regfile 

        if (rb_data[0] == 1){
          game_fsm.d = game_fsm.CHECK_LIVES_MORE_THAN_1;
        }
        else game_fsm.d = game_fsm.CHECKPP_EQ_E16;
     game_fsm.CHECKPP_EQ_E16:
        state_number             = b0110111;   // State number 55
        control_sig_alufn        = b110011;    // ALU operation for CMPEQ 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b10000;     // Register to store Enemy 16's state and position 
        control_sig_rc           = b10111;     // Temporary register to store output from ALU 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BRANCH_PP_EQ_E16;

     game_fsm.BRANCH_PP_EQ_E16:
        state_number             = b0111000;   // State number 56
        control_sig_rb           = b10111;     // Temporary register to store output from ALU 
        control_sig_write_enable = b0;         // Disable writing to regfile 

        if (rb_data[0] == 1){
          game_fsm.d = game_fsm.CHECK_LIVES_MORE_THAN_1;
        }
        else game_fsm.d = game_fsm.CHECK_END_REACHED;

     game_fsm.CHECK_LIVES_MORE_THAN_1:
        state_number             = b0111001;   // State number 57
        control_sig_alufn        = b110101;    // ALU operation for CMPLT 
        control_sig_asel         = b10;        // Select constant 1 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b10101;     // Register to store Player's lives left 
        control_sig_rc           = b10111;     // Temporary register to store output from ALU 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BRANCH_LIVES_MORE_THAN_1;

     game_fsm.BRANCH_LIVES_MORE_THAN_1:
        state_number             = b0111010;   // State number 58
        control_sig_rb           = b10111;     // Temporary register to store output from ALU 
        control_sig_write_enable = b0;         // Disable writing to regfile 

        if (rb_data[0] == 1){
          game_fsm.d = game_fsm.LIVES_MINUS;
        }
        else game_fsm.d = game_fsm.LOSE_LIVES; 

     game_fsm.LIVES_MINUS:
        state_number             = b0111011;   // State number 59
        control_sig_alufn        = b000001;    // ALU operation SUBTRACT 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b10101;     // Register to store Player's lives left 
        control_sig_rb           = b11011;     // Register to store value of 1 
        control_sig_rc           = b10101;     // Register to store Player's lives left 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.RESPAWN_PP;

     game_fsm.RESPAWN_PP:
        state_number             = b0111100;   // State number 60
        control_sig_alufn        = b000000;    // ALU operation ADD 
        control_sig_asel         = b01;        // Select constant 0 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b11100;     // Register storing value of player's start position 
        control_sig_rc           = b00000;     // Register to store Player's position 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.IDLE;
          
     game_fsm.LOSE_LIVES:
        state_number             = b0111101;   // State number 61
        control_sig_alufn        = b000001;    // ALU operation SUBTRACT 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b10101;     // Register to store Player's lives left 
        control_sig_rb           = b11011;     // Register to store value of 1 
        control_sig_rc           = b10101;     // Register to store Player's lives left 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.LOSE;

     game_fsm.LOSE:
        state_number             = b0111110;   // State number 62
        control_sig_alufn        = b000000;    // ALU operation ADD 
        control_sig_asel         = b10;        // Select constant 1 
        control_sig_bsel         = b01;        // Select constant 0 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b10110;     // Register to show '1' if game has stopped 
        control_sig_wdsel        = b00;        // Select ALU's output 
        if (reset_pressed){
          game_fsm.d = game_fsm.RESET_PP;}

     game_fsm.RESET_PP:
        state_number             = b0111111;   // State number 63
        control_sig_alufn        = b000000;    // ALU operation ADD 
        control_sig_asel         = b01;        // Select constant 0 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b11100;     // Register storing value of player's start position 
        control_sig_rc           = b00000;     // Register to store Player's position 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.RESET_STOP_GAME;

      game_fsm.RESET_STOP_GAME:
        state_number             = b1000000;   // State number 64
        control_sig_alufn        = b000000;    // ALU operation ADD 
        control_sig_asel         = b01;        // Select constant 0 
        control_sig_bsel         = b01;        // Select constant 0 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b10110;     // Register to show '1' if game has stopped 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.RESET_FAST_COUNTER;

      game_fsm.RESET_FAST_COUNTER:
        state_number             = b1000001;   // State number 65
        control_sig_alufn        = b000000;    // ALU operation ADD 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b10011;     // Register to store fast counter's value 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.RESET_SLOW_COUNTER;

      game_fsm.RESET_SLOW_COUNTER:
        state_number             = b1000010;   // State number 66
        control_sig_alufn        = b000000;    // ALU operation ADD 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b10100;     // Register to store Player's score / timer 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.RESET_LIVES;

     game_fsm.RESET_LIVES:
        state_number             = b1000011;   // State number 67
        control_sig_alufn        = b000000;    // ALU operation ADD 
        control_sig_asel         = b11;        // Select constant 3 
        control_sig_bsel         = b01;        // Select constant 0 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b10101;     // Register to store Player's lives left 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.RESET_LVL;

     game_fsm.RESET_LVL:
        state_number             = b1000100;   // State number 68
        control_sig_alufn        = b000000;    // ALU operation ADD 
        control_sig_asel         = b10;        // Select constant 1 
        control_sig_bsel         = b01;        // Select constant 0 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b10010;     // Register to store Player's current level 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.RESET_E1;
          
     game_fsm.RESET_E1:
        state_number             = b1000101;   // State number 69
        control_sig_alufn        = b011011;    // Custom ALU operation to set MSB for enemies to 0
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00001;     // Register to store Enemy 1's state and position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b00001;     // Register to store Enemy 1's state and position 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.RESET_E2;
          
     game_fsm.RESET_E2:
        state_number             = b1000110;   // State number 70
        control_sig_alufn        = b011011;    // Custom ALU operation to set MSB for enemies to 0
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00010;     // Register to store Enemy 2's state and position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b00010;     // Register to store Enemy 2's state and position 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.RESET_E3;
     
     game_fsm.RESET_E3:
        state_number             = b1000111;   // State number 71
        control_sig_alufn        = b011011;    // Custom ALU operation to set MSB for enemies to 0
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00011;     // Register to store Enemy 3's state and position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b00011;     // Register to store Enemy 3's state and position 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.RESET_E4;
          
     game_fsm.RESET_E4:
        state_number             = b1001000;   // State number 72
        control_sig_alufn        = b011011;    // Custom ALU operation to set MSB for enemies to 0
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00100;     // Register to store Enemy 4's state and position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b00100;     // Register to store Enemy 4's state and position 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.RESET_E5;
          
      game_fsm.RESET_E5:
        state_number             = b1001001;   // State number 73
        control_sig_alufn        = b011011;    // Custom ALU operation to set MSB for enemies to 0
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00101;     // Register to store Enemy 5's state and position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b00101;     // Register to store Enemy 5's state and position 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.RESET_E6;
          
      game_fsm.RESET_E6:
        state_number             = b1001010;   // State number 74
        control_sig_alufn        = b011011;    // Custom ALU operation to set MSB for enemies to 0
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00110;     // Register to store Enemy 6's state and position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b00110;     // Register to store Enemy 6's state and position 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.RESET_E7;
          
       game_fsm.RESET_E7:
        state_number             = b1001011;   // State number 75
        control_sig_alufn        = b011011;    // Custom ALU operation to set MSB for enemies to 0
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00111;     // Register to store Enemy 7's state and position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b00111;     // Register to store Enemy 7's state and position 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.RESET_E8;
          
       game_fsm.RESET_E8:
        state_number             = b1001100;   // State number 76
        control_sig_alufn        = b011011;    // Custom ALU operation to set MSB for enemies to 0
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b01000;     // Register to store Enemy 8's state and position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b01000;     // Register to store Enemy 8's state and position 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.RESET_E9;
          
       game_fsm.RESET_E9:
        state_number             = b1001101;   // State number 77
        control_sig_alufn        = b011011;    // Custom ALU operation to set MSB for enemies to 0
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b01001;     // Register to store Enemy 9's state and position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b01001;     // Register to store Enemy 9's state and position 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.RESET_E10;
          
       game_fsm.RESET_E10:
        state_number             = b1001110;   // State number 78
        control_sig_alufn        = b011011;    // Custom ALU operation to set MSB for enemies to 0
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b01010;     // Register to store Enemy 10's state and position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b01010;     // Register to store Enemy 10's state and position 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.RESET_E11;
          
       game_fsm.RESET_E11:
        state_number             = b1001111;   // State number 79
        control_sig_alufn        = b011011;    // Custom ALU operation to set MSB for enemies to 0
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b01011;     // Register to store Enemy 11's state and position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b01011;     // Register to store Enemy 11's state and position 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.IDLE;

     game_fsm.PP_PLUS:
        state_number             = b1010000;   // State number 80
        control_sig_alufn        = b000000;    // ALU operation ADD 
        control_sig_asel         = b10;        // Select constant 1 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b00000;     // Register to store Player's position 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.CHECKPP_EQ_E1;

     game_fsm.CHECK_PP:
        state_number             = b1010001;   // State number 81
        control_sig_alufn        = b110101;    // ALU operation for CMPLT 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b11100;     // Register storing value of player's start position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b11111;     // Temporary register to store output from ALU 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BRANCH_PP;


     game_fsm.BRANCH_PP:
        state_number             = b1010010;   // State number 82
        control_sig_rb           = b11111;     // Temporary register to store output from ALU 
        control_sig_write_enable = b0;         // Disable writing to regfile 

        if (rb_data[0] == 1){
          game_fsm.d = game_fsm.PP_MINUS;
        }
        else game_fsm.d = game_fsm.IDLE;

     game_fsm.PP_MINUS:
        state_number             = b1010011;   // State number 83
        control_sig_alufn        = b000001;    // ALU operation SUBTRACT 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b11011;     // Register to store value of 1 
        control_sig_rc           = b00000;     // Register to store Player's position 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.CHECKPP_EQ_E1;

     game_fsm.CHECK_END_REACHED:
        state_number             = b1010100;   // State number 84
        control_sig_alufn        = b110011;    // ALU operation for CMPEQ 
        control_sig_asel         = b00;        // Select Register A's data from regfile 
        control_sig_bsel         = b10;        // Select constant hx801F - end of LED strip 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b10111;     // Temporary register to store output from ALU 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BRANCH_END_REACHED;

     game_fsm.BRANCH_END_REACHED:
        state_number             = b1010101;   // State number 85
        control_sig_rb           = b10111;     // Temporary register to store output from ALU 
        control_sig_write_enable = b0;         // Disable writing to regfile 
        result = rb_data;

        if (rb_data[0] == 1){
        game_fsm.d = game_fsm.CHECK_NEXTLVL_EXISTS; 
        }
        else game_fsm.d = game_fsm.IDLE; 
          
     game_fsm.CHECK_NEXTLVL_EXISTS:
        state_number             = b1010110;   // State number 86
        control_sig_alufn        = b110011;    // ALU operation for CMPEQ 
        control_sig_asel         = b11;        // Select constant 3 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b10010;     // Register to store Player's current level 
        control_sig_rc           = b10111;     // Temporary register to store output from ALU 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BRANCH_NEXT_LVL_EXISTS;

     game_fsm.BRANCH_NEXT_LVL_EXISTS:
        state_number             = b1010111;   // State number 87
        control_sig_rb           = b10111;     // Temporary register to store output from ALU 
        control_sig_write_enable = b0;         // Disable writing to regfile 
        
        if (rb_data[0] == 1){
          game_fsm.d = game_fsm.WIN;
        }
        else game_fsm.d = game_fsm.CURRENT_LVL_PLUS;
          
     game_fsm.CURRENT_LVL_PLUS:
        state_number             = b1011000;   // State number 88
        control_sig_alufn        = b000000;    // ALU operation ADD 
        control_sig_asel         = b10;        // Select constant 1 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b10010;     // Register to store Player's current level 
        control_sig_rc           = b10010;     // Register to store Player's current level 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.NEXT_LVL_PP;

     game_fsm.NEXT_LVL_PP:
        state_number             = b1011001;   // State number 89
        control_sig_alufn        = b000000;    // ALU operation ADD 
        control_sig_asel         = b01;        // Select constant 0 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b11100;     // Register storing value of player's start position 
        control_sig_rc           = b00000;     // Register to store Player's position 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.IDLE;

     game_fsm.WIN:
        state_number             = b1011010;   // State number 90
        control_sig_alufn        = b000000;    // ALU operation ADD 
        control_sig_asel         = b10;        // Select constant 1 
        control_sig_bsel         = b01;        // Select constant 0 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b00000;     // Register to store Player's position 
        control_sig_rc           = b10110;     // Register to show '1' if game has stopped 
        control_sig_wdsel        = b00;        // Select ALU's output 
        if (reset_pressed){
          game_fsm.d = game_fsm.RESET_PP;}

     game_fsm.CHECK_STOP_GAME:
        state_number             = b1011011;   // State number 91
        control_sig_alufn        = b110011;    // ALU operation for CMPEQ 
        control_sig_asel         = b10;        // Select constant 1 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b10110;     // Register to show '1' if game has stopped 
        control_sig_rc           = b10111;     // Temporary register to store output from ALU 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.BRANCH_STOP_GAME;

     game_fsm.BRANCH_STOP_GAME:
        state_number             = b1011100;   // State number 92
        control_sig_rb           = b10111;     // Temporary register to store output from ALU 
        control_sig_write_enable = b0;         // Disable writing to regfile 

        if (rb_data[0] == 1){
          game_fsm.d = game_fsm.IDLE;
        }
        else game_fsm.d = game_fsm.SLOW_COUNTER_PLUS;

     game_fsm.SLOW_COUNTER_PLUS:
        state_number             = b1011101;   // State number 93
        control_sig_alufn        = b000000;    // ALU operation ADD 
        control_sig_asel         = b10;        // Select constant 1 
        control_sig_bsel         = b00;        // Select Register A's data from regfile 
        control_sig_write_enable = b1;         // Enable writing to regfile 
        control_sig_ra           = b00000;     // Register to store Player's position 
        control_sig_rb           = b10100;     // Register to store Player's score / timer 
        control_sig_rc           = b10100;     // Register to store Player's score / timer 
        control_sig_wdsel        = b00;        // Select ALU's output 
        game_fsm.d = game_fsm.IDLE;
  }
}
