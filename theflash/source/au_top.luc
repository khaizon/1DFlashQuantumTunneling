module au_top (
    input clk,              // 100MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    output io_led [3][8],   // LEDs on IO Shield
    input io_button [5],    // 5 buttons on IO Shield
    // io_button[0] is up, io_button[1] is center, io_button[2] is down, io_button[3] is left, and io_button[4] is right.
    input usb_rx,           // USB->Serial input
    output usb_tx,          // USB->Serial output
    output io_seg [8],      // 7-segment LEDs on IO Shield
    output io_sel [4],      // Digit select on IO Shield
    input io_dip [3][8],     // DIP switches on IO Shield
    output outled,
    input customin[1],
    input custominbackward[1],
    input custominreset[1],
    output livesled[3],
    output levelled[3]
  ) {
  
  sig rst;                  // reset signal
  ws2812b_writer led_strip(#PIXEL_COUNT(32), .clk(clk), .rst(rst)); //set for 3 pixels
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    
    reset_conditioner reset_cond;
    
    // detect up and down button pressers of player
    edge_detector edge_dt_btn_up (#RISE(1), #FALL(0));
    edge_detector edge_dt_btn_down(#RISE(1), #FALL(0));
    edge_detector edge_dt_btn_mid(#RISE(1), #FALL(0));

    // button conditioner for up and down button
    button_conditioner btn_cond_up;
    button_conditioner btn_cond_down;
    button_conditioner btn_cond_mid;
    
    .rst(rst){
      // counter timer(#SIZE(1), #DIV(25));
      game_customBeta gameMachine;
      multi_seven_seg test_display;
     }
    
  }
  converter converter;
  entities_handler entities_hand;
  lives_and_levels lives_and_levels_handler;
  always {
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
    
    led = 8h00;             // turn LEDs off
    io_seg = 8hff;          // turn segments off
    io_sel = 4hf;           // select no digits

    usb_tx = usb_rx;        // echo the serial data
    
    // io_led = 3x{{8h00}};    // turn LEDs off
    io_led = 3x{{8h00}};
    io_led[0] = c{gameMachine.slow_counter_time[7:0]};
    io_led[1] = c{gameMachine.e14position[15], gameMachine.e15position[15], gameMachine.e8position[15], gameMachine.e7position[15], gameMachine.e16position[15], gameMachine.e3position[15], gameMachine.e2position[15], gameMachine.e1position[15]};
    io_led[2] = c{gameMachine.e12position[15], gameMachine.e13position[15], gameMachine.e11position[15], gameMachine.e10position[15], gameMachine.e6position[15], gameMachine.e5position[15], gameMachine.e4position[15], gameMachine.e9position[15]};
    // interchange w pp for debugging 
   // io_led[0] = c{0,gameMachine.state_number};
    //io_led[1] = gameMachine.result[7:0];
    //io_led[2] = gameMachine.result[15:8];
    
    
    btn_cond_up.in=customin[0]; //to reduce the bouncing effects of your button 
    btn_cond_down.in=custominbackward[0]; // must change to external button io
    btn_cond_mid.in=custominreset[0];
    edge_dt_btn_up.in=btn_cond_up.out; //get the edge of button press
    edge_dt_btn_down.in=btn_cond_down.out;
    edge_dt_btn_mid.in=btn_cond_mid.out;
    
    
    // detect up and down button presses
    // serves as input into our game's beta CPU 
    gameMachine.up_button = edge_dt_btn_up.out;
    
    gameMachine.down_button = edge_dt_btn_down.out;
    gameMachine.middle_button = edge_dt_btn_mid.out;
    
    lives_and_levels_handler.lives = gameMachine.lives[1:0];
    lives_and_levels_handler.level = gameMachine.level[1:0];
    livesled = lives_and_levels_handler.livesled_out;
    levelled = lives_and_levels_handler.levelled_out;
    // set LED strip to display output of gameMachine
    // io_led[0] = gameMachine.p1_out;    
    // io_led[1] = gameMachine.p2_out;
    io_seg = ~test_display.seg;
    converter.pp = gameMachine.playerposition;
    converter.lives = gameMachine.lives;
    converter.level = gameMachine.level;
    test_display.values = converter.out;
    io_sel = ~test_display.sel;
  
    
    entities_hand.e6position = gameMachine.e6position;
    entities_hand.e16position = gameMachine.e16position;
    entities_hand.e11position = gameMachine.e11position;
    entities_hand.playerposition = gameMachine.playerposition;
    entities_hand.lives_left = gameMachine.lives;
    entities_hand.playerwon = gameMachine.player_won;
    
    led_strip.color = entities_hand.out[led_strip.pixel];
    led_strip.update = 1;
    outled = led_strip.led;
    
    
  }
}